# DocVault v2.1 Refinement Plan

**Version**: 2.1.0  
**Status**: Planning  
**Created**: November 21, 2025  
**Priority**: High (Technical Debt & API Consistency)

---

## Executive Summary

This plan addresses critical technical debt and API inconsistencies discovered in v2.0.0. These refinements improve developer experience, API clarity, and implementation completeness without breaking the v2.0 architecture.

### Key Issues Identified

1. **Upload API Gaps**: Incomplete file input handling, unused prefix parameter, duplicate replace method
2. **Method Signature Inconsistencies**: Deprecated v1.0 parameters still present, inconsistent UUID handling
3. **Unimplemented Features**: Hierarchical document listing (prefix, recursive, max_depth) not working
4. **Permission Security Gap**: get_document_details allows non-owners to see permissions
5. **Parameter Waste**: Unused parameters (org_id in get_permissions)
6. **Type Safety**: Using dicts instead of models for set_permissions
7. **Documentation Gaps**: Missing raises clauses in docstrings

---

## Table of Contents

1. [Issue Analysis](#issue-analysis)
2. [Refinement Tasks](#refinement-tasks)
3. [Implementation Plan](#implementation-plan)
4. [Testing Strategy](#testing-strategy)
5. [Timeline](#timeline)

---

## Issue Analysis

### Issue 1: Upload Method Incompleteness

**Current State:**
```python
async def upload(
    self,
    file_input: str | bytes | BinaryIO,  # ✅ Type signature correct
    prefix: Optional[str] = None,        # ❌ Parameter accepted but NOT USED
    ...
) -> Document:
    return await self._document_service.upload_enhanced(
        # prefix is NOT passed to service! ❌
    )
```

**Problems:**
1. ✅ Type signature supports str, bytes, BinaryIO - GOOD
2. ❌ `prefix` parameter accepted but **never used** - silently ignored
3. ❌ Separate `replace()` method exists - should be unified with upload
4. ❌ No tests for each file input type (str path, str content, bytes, BinaryIO)
5. ❌ No examples demonstrating different input types

**Expected Behavior:**
- Upload should accept file path (str), text content (str), bytes, or BinaryIO
- When document exists, `create_version=True` creates new version
- When document exists, `create_version=False` replaces current version
- `prefix` parameter should organize documents hierarchically
- `change_description` should document version changes

---

### Issue 2: Method Signature Inconsistencies

**Current State:**
```python
# ❌ Still has v1.0 'name' parameter
async def register_organization(
    self,
    external_id: str,           # ❌ Should be org_id: UUID | str
    name: str = None,           # ❌ Deprecated but still present
    metadata: Optional[Dict[str, Any]] = None,
)

# ❌ Similar issues
async def register_agent(
    self,
    external_id: str,           # ❌ Should be agent_id: UUID | str
    organization_id: str,       # ❌ Should accept UUID | str
    name: str = None,           # ❌ Deprecated parameter
    email: Optional[str] = None,  # ❌ Deprecated parameter
    agent_type: str = "human",  # ❌ Deprecated parameter
    ...
)

# ❌ Inconsistent parameter names
async def get_organization(
    self,
    external_id: str            # ❌ Should be org_id: UUID | str
)

async def get_agent(
    self,
    external_id: str            # ❌ Should be agent_id: UUID | str
)
```

**Problems:**
1. Deprecated v1.0 parameters (`name`, `email`, `agent_type`) still accepted
2. Inconsistent parameter naming (`external_id` vs `org_id`/`agent_id`)
3. Type hints don't accept UUID (only str)
4. Confusing for new users - which parameters actually work?

**Expected Behavior:**
- Remove all v1.0-only parameters completely
- Use consistent naming: `org_id`, `agent_id`, `document_id`
- Accept both UUID and str for all ID parameters
- Clear, v2.0-only API

---

### Issue 3: Hierarchical Document Listing Not Implemented

**Current State:**
```python
async def list_docs(
    self,
    prefix: Optional[str] = None,        # ❌ ACCEPTED BUT NOT USED
    recursive: bool = False,             # ❌ ACCEPTED BUT NOT USED
    max_depth: Optional[int] = None,     # ❌ ACCEPTED BUT NOT USED
    ...
) -> Dict[str, Any]:
    return await self._document_service.list_documents_paginated(
        # prefix, recursive, max_depth NOT PASSED! ❌
        organization_id=organization_id,
        agent_id=agent_id,
        status=status,
        tags=tags,
        # Missing hierarchical parameters
    )
```

**Problems:**
1. Parameters accepted but **silently ignored**
2. `list_documents_paginated()` doesn't support hierarchical filtering
3. No way to list documents by prefix
4. No recursive listing support
5. Users expect these to work but they don't

**Expected Behavior:**
- `prefix="/reports/2025/"` lists only documents under that prefix
- `recursive=True` lists all documents under prefix, recursively
- `max_depth=2` limits recursion depth
- Service layer actually implements these filters

---

### Issue 4: Permission Security Gap

**Current State:**
```python
async def get_document_details(
    self,
    document_id: str | UUID,
    agent_id: str | UUID,
    include_versions: bool = True,
    include_permissions: bool = False,  # ❌ NO OWNERSHIP CHECK
):
    # Anyone with READ access can see permissions! ❌
    if include_permissions:
        details["permissions"] = await get_permissions(...)
```

**Problem:**
- Any agent with READ permission can see ALL document permissions
- Security issue: non-owners shouldn't see who else has access
- Expected: Only document owner (ADMIN permission) should see permissions

**Expected Behavior:**
```python
if include_permissions:
    # Check if agent is owner (has ADMIN permission)
    agent_perms = await get_permissions(document_id, agent_id)
    is_owner = any(p["permission"] == "ADMIN" for p in agent_perms.get("permissions", []))
    if not is_owner:
        raise PermissionDeniedError("Only document owners can view permissions")
    details["permissions"] = await get_permissions(...)
```

---

### Issue 5: Unused Parameter - get_permissions

**Current State:**
```python
async def get_permissions(
    self,
    document_id: str | UUID,
    agent_id: Optional[str | UUID] = None,
    org_id: Optional[str | UUID] = None,  # ❌ NEVER USED
) -> Dict[str, Any]:
    return await self._access_service.get_permissions_detailed(
        document_id=document_id,
        agent_id=agent_id,
        # org_id NOT PASSED - completely unused ❌
    )
```

**Problem:**
- `org_id` parameter accepted but never used
- No validation, no filtering, no purpose
- Misleads users into thinking it does something

**Solution:**
- **Option A**: Remove `org_id` parameter entirely (RECOMMENDED)
- **Option B**: Implement org-level permission filtering
- **Decision**: Remove it - permissions are document-scoped, not org-scoped

---

### Issue 6: Type Safety - set_permissions

**Current State:**
```python
async def set_permissions(
    self,
    document_id: str | UUID,
    permissions: List[dict],  # ❌ Using plain dict
    granted_by: str | UUID,
) -> List[Any]:
    """
    Example:
        permissions=[
            {"agent_id": agent1, "permission": "READ"},  # ❌ Untyped dict
        ]
    """
```

**Problem:**
- Using plain `dict` instead of Pydantic model
- No validation on permission structure
- No type hints for IDE support
- Runtime errors instead of validation errors

**Expected Behavior:**
```python
# Create Permission model
class PermissionGrant(BaseModel):
    agent_id: UUID | str
    permission: str  # READ, WRITE, DELETE, SHARE, ADMIN
    expires_at: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None

async def set_permissions(
    self,
    document_id: str | UUID,
    permissions: List[PermissionGrant],  # ✅ Typed model
    granted_by: str | UUID,
) -> List[DocumentACL]:
    # Pydantic validation ensures correct structure
```

---

### Issue 7: Missing Raises in Docstrings

**Current State:**
```python
async def upload(
    self,
    file_input: str | bytes | BinaryIO,
    name: str,
    ...
) -> Document:
    """
    Upload a document.
    
    Args:
        file_input: File path, bytes, or stream
        ...
    
    Returns:
        Document: The uploaded document
    
    # ❌ NO RAISES SECTION - users don't know what exceptions to catch
    """
```

**Problem:**
- No documentation of exceptions
- Users don't know what to catch
- Debugging harder without error documentation

**Expected Behavior:**
```python
async def upload(...) -> Document:
    """
    Upload a document.
    
    Args:
        ...
    
    Returns:
        Document: The uploaded document
    
    Raises:
        ValidationError: If file_input type is invalid
        OrganizationNotFoundError: If organization doesn't exist
        AgentNotFoundError: If agent doesn't exist
        StorageError: If file upload fails
        PermissionDeniedError: If agent lacks permission
        DocumentExistsError: If document exists and create_version=False
    """
```

---

## Refinement Tasks

### Task 1: Unify Upload and Replace Methods ⚡ HIGH PRIORITY

**Objective**: Merge `replace()` into `upload()` with version control parameters.

#### 1.1: Update SDK Method Signature
**File**: `src/doc_vault/core.py`

**Changes:**
```python
async def upload(
    self,
    file_input: str | bytes | BinaryIO,
    name: str,
    organization_id: str | UUID,
    agent_id: str | UUID,
    description: Optional[str] = None,
    tags: Optional[List[str]] = None,
    metadata: Optional[Dict[str, Any]] = None,
    content_type: Optional[str] = None,
    filename: Optional[str] = None,
    prefix: Optional[str] = None,              # ✅ NOW USED
    create_version: bool = True,                # ✅ NEW: Create version if exists
    change_description: Optional[str] = None,  # ✅ NEW: Version change note
) -> Document:
    """
    Upload a document or create new version if exists.
    
    Supports multiple input types:
    - File path (str): '/path/to/file.pdf'
    - Text content (str): 'Document content text'
    - Bytes (bytes): b'binary content'
    - Binary stream (BinaryIO): open('file.pdf', 'rb')
    
    Args:
        file_input: File path (str), text content (str), bytes, or binary stream
        name: Document display name
        organization_id: Organization UUID or string
        agent_id: Agent UUID or string (uploader)
        description: Optional document description
        tags: Optional list of tags
        metadata: Optional custom metadata
        content_type: Optional MIME type (auto-detected if None)
        filename: Optional filename override
        prefix: Optional hierarchical prefix (e.g., '/reports/2025/')
        create_version: If True and document exists, create new version.
                       If False and document exists, replace current version.
        change_description: Description of changes (for versioning)
    
    Returns:
        Document: The uploaded/updated document
    
    Raises:
        ValidationError: If file_input type is invalid or parameters are invalid
        OrganizationNotFoundError: If organization doesn't exist
        AgentNotFoundError: If agent doesn't exist
        StorageError: If file upload fails
        PermissionDeniedError: If agent lacks WRITE permission (for updates)
        DocumentNotFoundError: If updating non-existent document
    
    Examples:
        # Upload from file path
        doc = await vault.upload(
            file_input="/path/to/report.pdf",
            name="Q4 Report",
            organization_id=org_id,
            agent_id=agent_id,
            prefix="/reports/2025/q4/"
        )
        
        # Upload text content
        doc = await vault.upload(
            file_input="This is my document content",
            name="Meeting Notes",
            organization_id=org_id,
            agent_id=agent_id,
            content_type="text/plain"
        )
        
        # Upload bytes
        content = requests.get(url).content
        doc = await vault.upload(
            file_input=content,
            name="Downloaded File",
            organization_id=org_id,
            agent_id=agent_id
        )
        
        # Upload from stream
        with open('large_file.zip', 'rb') as f:
            doc = await vault.upload(
                file_input=f,
                name="Large Archive",
                organization_id=org_id,
                agent_id=agent_id
            )
        
        # Create new version of existing document
        doc = await vault.upload(
            file_input="/path/to/updated_report.pdf",
            name="Q4 Report",  # Same name = update
            organization_id=org_id,
            agent_id=agent_id,
            create_version=True,
            change_description="Updated with final numbers"
        )
        
        # Replace current version (no history)
        doc = await vault.upload(
            file_input=corrected_bytes,
            name="Q4 Report",
            organization_id=org_id,
            agent_id=agent_id,
            create_version=False,
            change_description="Fixed typo"
        )
    """
```

#### 1.2: Update Service Layer
**File**: `src/doc_vault/services/document_service.py`

**Changes:**
1. Update `upload_enhanced()` to accept `prefix`, `create_version`, `change_description`
2. Check if document with same name+org+prefix exists
3. If exists and `create_version=True`: create new version
4. If exists and `create_version=False`: replace current version
5. If not exists: create new document (ignore create_version)

**Implementation:**
```python
async def upload_enhanced(
    self,
    file_input: Union[str, bytes, BinaryIO],
    name: str,
    organization_id: UUID | str,
    agent_id: UUID | str,
    description: Optional[str] = None,
    tags: Optional[List[str]] = None,
    metadata: Optional[Dict[str, Any]] = None,
    content_type: Optional[str] = None,
    filename: Optional[str] = None,
    prefix: Optional[str] = None,
    create_version: bool = True,
    change_description: Optional[str] = None,
) -> Document:
    """Upload document with version control support."""
    
    # Ensure UUIDs
    organization_id = self._ensure_uuid(organization_id)
    agent_id = self._ensure_uuid(agent_id)
    
    # Check if document exists with same name+org+prefix
    existing_doc = await self._find_existing_document(
        name=name,
        organization_id=organization_id,
        prefix=prefix
    )
    
    if existing_doc:
        # Document exists - update or create version
        if create_version:
            return await self._create_new_version(
                document=existing_doc,
                file_input=file_input,
                agent_id=agent_id,
                change_description=change_description or "Updated document",
                filename=filename,
                content_type=content_type,
            )
        else:
            return await self._replace_current_version(
                document=existing_doc,
                file_input=file_input,
                agent_id=agent_id,
                change_description=change_description or "Replaced document",
                filename=filename,
                content_type=content_type,
            )
    else:
        # New document - create
        return await self._create_new_document(
            file_input=file_input,
            name=name,
            organization_id=organization_id,
            agent_id=agent_id,
            description=description,
            tags=tags,
            metadata=metadata,
            content_type=content_type,
            filename=filename,
            prefix=prefix,
        )
```

#### 1.3: Remove replace() Method
**File**: `src/doc_vault/core.py`

**Action**: Delete the `replace()` method entirely - functionality merged into `upload()`.

#### 1.4: Add Tests for All Input Types
**File**: `tests/test_core_upload.py` (NEW)

**Test Cases:**
```python
class TestUploadFileInput:
    async def test_upload_from_file_path(self, vault, tmp_path):
        """Test upload from file path string."""
        file_path = tmp_path / "test.txt"
        file_path.write_text("Test content")
        
        doc = await vault.upload(
            file_input=str(file_path),
            name="Test Doc",
            organization_id=org_id,
            agent_id=agent_id
        )
        
        assert doc.name == "Test Doc"
        assert doc.file_size == len("Test content")
    
    async def test_upload_from_text_content(self, vault):
        """Test upload from text string content."""
        doc = await vault.upload(
            file_input="This is text content",
            name="Text Doc",
            organization_id=org_id,
            agent_id=agent_id,
            content_type="text/plain"
        )
        
        assert doc.mime_type == "text/plain"
    
    async def test_upload_from_bytes(self, vault):
        """Test upload from bytes."""
        content = b"Binary content here"
        doc = await vault.upload(
            file_input=content,
            name="Binary Doc",
            organization_id=org_id,
            agent_id=agent_id
        )
        
        assert doc.file_size == len(content)
    
    async def test_upload_from_binary_stream(self, vault, tmp_path):
        """Test upload from BinaryIO stream."""
        file_path = tmp_path / "stream.dat"
        file_path.write_bytes(b"Stream data")
        
        with open(file_path, 'rb') as f:
            doc = await vault.upload(
                file_input=f,
                name="Stream Doc",
                organization_id=org_id,
                agent_id=agent_id
            )
        
        assert doc.name == "Stream Doc"
    
    async def test_upload_with_prefix(self, vault):
        """Test upload with hierarchical prefix."""
        doc = await vault.upload(
            file_input="Content",
            name="Prefixed Doc",
            organization_id=org_id,
            agent_id=agent_id,
            prefix="/reports/2025/q1/"
        )
        
        assert doc.prefix == "/reports/2025/q1/"
        assert doc.path == "/reports/2025/q1/Prefixed Doc"

class TestUploadVersionControl:
    async def test_create_version_when_exists(self, vault):
        """Test creating new version when document exists."""
        # Upload initial version
        doc1 = await vault.upload(
            file_input="Version 1 content",
            name="Versioned Doc",
            organization_id=org_id,
            agent_id=agent_id
        )
        assert doc1.current_version == 1
        
        # Upload again with same name - creates version 2
        doc2 = await vault.upload(
            file_input="Version 2 content",
            name="Versioned Doc",
            organization_id=org_id,
            agent_id=agent_id,
            create_version=True,
            change_description="Updated content"
        )
        
        assert doc2.id == doc1.id  # Same document
        assert doc2.current_version == 2
    
    async def test_replace_version_when_exists(self, vault):
        """Test replacing current version (no history)."""
        # Upload initial version
        doc1 = await vault.upload(
            file_input="Version 1",
            name="Replace Doc",
            organization_id=org_id,
            agent_id=agent_id
        )
        
        # Replace (not versioned)
        doc2 = await vault.upload(
            file_input="Replaced content",
            name="Replace Doc",
            organization_id=org_id,
            agent_id=agent_id,
            create_version=False
        )
        
        assert doc2.id == doc1.id
        assert doc2.current_version == 1  # Still version 1
        
        # Verify history doesn't show old content
        details = await vault.get_document_details(
            document_id=doc2.id,
            agent_id=agent_id,
            include_versions=True
        )
        assert len(details["versions"]) == 1  # Only current version
```

#### 1.5: Add Examples
**File**: `examples/upload_types.py` (NEW)

**Content**: Demonstrate all upload types with real code examples.

---

### Task 2: Clean Up Method Signatures ⚡ HIGH PRIORITY

**Objective**: Remove v1.0 parameters and standardize naming.

#### 2.1: Update register_organization()
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def register_organization(
    self,
    external_id: str,
    name: str = None,
    metadata: Optional[Dict[str, Any]] = None,
):
```

**After:**
```python
async def register_organization(
    self,
    org_id: UUID | str,
    metadata: Optional[Dict[str, Any]] = None,
) -> Organization:
    """
    Register a new organization.
    
    Args:
        org_id: Organization UUID (as UUID or string)
        metadata: Optional custom metadata
    
    Returns:
        Organization: The registered organization
    
    Raises:
        ValidationError: If org_id is invalid UUID
        OrganizationExistsError: If organization already exists
    """
```

#### 2.2: Update register_agent()
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def register_agent(
    self,
    external_id: str,
    organization_id: str,
    name: str = None,
    email: Optional[str] = None,
    agent_type: str = "human",
    metadata: Optional[Dict[str, Any]] = None,
):
```

**After:**
```python
async def register_agent(
    self,
    agent_id: UUID | str,
    organization_id: UUID | str,
    metadata: Optional[Dict[str, Any]] = None,
) -> Agent:
    """
    Register a new agent in an organization.
    
    Args:
        agent_id: Agent UUID (as UUID or string)
        organization_id: Organization UUID (as UUID or string)
        metadata: Optional custom metadata (can store name, email, type, etc.)
    
    Returns:
        Agent: The registered agent
    
    Raises:
        ValidationError: If UUIDs are invalid
        OrganizationNotFoundError: If organization doesn't exist
        AgentExistsError: If agent already exists
    
    Example:
        agent = await vault.register_agent(
            agent_id="550e8400-e29b-41d4-a716-446655440000",
            organization_id=org_id,
            metadata={
                "name": "John Doe",
                "email": "john@example.com",
                "type": "human",
                "role": "admin"
            }
        )
    """
```

#### 2.3: Update get_organization()
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def get_organization(self, external_id: str):
```

**After:**
```python
async def get_organization(
    self,
    org_id: UUID | str
) -> Organization:
    """
    Get organization by ID.
    
    Args:
        org_id: Organization UUID (as UUID or string)
    
    Returns:
        Organization: The organization
    
    Raises:
        ValidationError: If org_id is invalid UUID
        OrganizationNotFoundError: If organization doesn't exist
    """
```

#### 2.4: Update get_agent()
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def get_agent(self, external_id: str):
```

**After:**
```python
async def get_agent(
    self,
    agent_id: UUID | str
) -> Agent:
    """
    Get agent by ID.
    
    Args:
        agent_id: Agent UUID (as UUID or string)
    
    Returns:
        Agent: The agent
    
    Raises:
        ValidationError: If agent_id is invalid UUID
        AgentNotFoundError: If agent doesn't exist
    """
```

#### 2.5: Update All Examples
**Files**: `examples/*.py`

**Changes**: Update all examples to use new parameter names (`org_id`, `agent_id` instead of `external_id`).

---

### Task 3: Implement Hierarchical Document Listing ⚡ HIGH PRIORITY

**Objective**: Make prefix, recursive, and max_depth parameters actually work.

#### 3.1: Update Service Layer
**File**: `src/doc_vault/services/document_service.py`

**Changes:**
```python
async def list_documents_paginated(
    self,
    organization_id: UUID | str,
    agent_id: UUID | str,
    prefix: Optional[str] = None,       # ✅ NOW IMPLEMENTED
    recursive: bool = False,            # ✅ NOW IMPLEMENTED
    max_depth: Optional[int] = None,    # ✅ NOW IMPLEMENTED
    status: Optional[str] = None,
    tags: Optional[List[str]] = None,
    limit: int = 50,
    offset: int = 0,
    sort_by: str = "created_at",
    sort_order: str = "desc",
) -> Dict[str, Any]:
    """
    List documents with hierarchical filtering.
    
    Args:
        organization_id: Organization UUID
        agent_id: Agent UUID (requester)
        prefix: Filter by prefix (e.g., '/reports/2025/')
        recursive: If True, include all documents under prefix
        max_depth: Maximum recursion depth (None = unlimited)
        ...
    
    Returns:
        Dict with documents list and metadata
    """
    
    # Resolve UUIDs
    organization_id = self._ensure_uuid(organization_id)
    agent_id = self._ensure_uuid(agent_id)
    
    # Query documents
    if prefix and recursive:
        # Recursive listing
        documents = await self.document_repo.list_recursive(
            organization_id=organization_id,
            prefix=prefix,
            max_depth=max_depth,
            limit=limit,
            offset=offset
        )
    elif prefix:
        # Flat listing with prefix filter
        documents = await self.document_repo.list_by_prefix(
            organization_id=organization_id,
            prefix=prefix,
            limit=limit,
            offset=offset
        )
    else:
        # No prefix filter - list all
        documents = await self.document_repo.list_by_organization(
            organization_id=organization_id,
            limit=limit,
            offset=offset
        )
    
    # Filter by permissions
    accessible_docs = []
    for doc in documents:
        try:
            await self._check_permission(doc.id, agent_id, "READ")
            accessible_docs.append(doc)
        except PermissionDeniedError:
            continue
    
    # Apply additional filters (status, tags)
    filtered_docs = self._apply_filters(
        accessible_docs,
        status=status,
        tags=tags
    )
    
    # Sort
    sorted_docs = self._sort_documents(filtered_docs, sort_by, sort_order)
    
    return {
        "documents": [self._document_to_dict(d) for d in sorted_docs],
        "pagination": {
            "limit": limit,
            "offset": offset,
            "total": len(sorted_docs),
            "has_more": len(sorted_docs) == limit
        },
        "filters": {
            "prefix": prefix,
            "recursive": recursive,
            "max_depth": max_depth,
            "status": status,
            "tags": tags
        }
    }
```

#### 3.2: Update Repository Layer
**File**: `src/doc_vault/database/repositories/document.py`

**Verify Methods Exist:**
- `list_by_prefix(org_id, prefix, limit, offset)`
- `list_recursive(org_id, prefix, max_depth, limit, offset)`

**If Missing, Implement:**
```python
async def list_by_prefix(
    self,
    organization_id: UUID,
    prefix: str,
    limit: int = 50,
    offset: int = 0
) -> List[Document]:
    """List documents matching prefix exactly."""
    query = """
        SELECT * FROM documents
        WHERE organization_id = $1
          AND prefix = $2
          AND status != 'deleted'
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
    """
    # Execute and return

async def list_recursive(
    self,
    organization_id: UUID,
    prefix: str,
    max_depth: Optional[int] = None,
    limit: int = 50,
    offset: int = 0
) -> List[Document]:
    """List documents under prefix recursively."""
    query = """
        SELECT * FROM documents
        WHERE organization_id = $1
          AND (prefix = $2 OR prefix LIKE $2 || '%')
          AND status != 'deleted'
    """
    
    if max_depth is not None:
        # Calculate depth and filter
        query += " AND calculate_depth(prefix, $2) <= $3"
    
    query += " ORDER BY prefix, name LIMIT $4 OFFSET $5"
    # Execute and return
```

#### 3.3: Add Tests
**File**: `tests/test_core_list_docs.py` (NEW)

**Test Cases:**
```python
class TestListDocsHierarchical:
    async def test_list_with_prefix(self, vault):
        """Test listing documents by prefix."""
        # Upload to different prefixes
        await vault.upload(..., prefix="/reports/")
        await vault.upload(..., prefix="/reports/2025/")
        await vault.upload(..., prefix="/projects/")
        
        # List only /reports/
        result = await vault.list_docs(
            organization_id=org_id,
            agent_id=agent_id,
            prefix="/reports/",
            recursive=False
        )
        
        assert len(result["documents"]) == 1  # Only direct children
    
    async def test_list_recursive(self, vault):
        """Test recursive listing."""
        # Upload nested structure
        await vault.upload(..., prefix="/reports/")
        await vault.upload(..., prefix="/reports/2025/")
        await vault.upload(..., prefix="/reports/2025/q1/")
        
        result = await vault.list_docs(
            organization_id=org_id,
            agent_id=agent_id,
            prefix="/reports/",
            recursive=True
        )
        
        assert len(result["documents"]) == 3  # All nested docs
    
    async def test_list_with_max_depth(self, vault):
        """Test depth-limited recursive listing."""
        result = await vault.list_docs(
            organization_id=org_id,
            agent_id=agent_id,
            prefix="/reports/",
            recursive=True,
            max_depth=1
        )
        
        # Only reports/ and reports/2025/, not reports/2025/q1/
        assert len(result["documents"]) == 2
```

---

### Task 4: Fix Permission Security Gap ⚡ MEDIUM PRIORITY

**Objective**: Only document owners can see permissions in get_document_details().

#### 4.1: Update get_document_details()
**File**: `src/doc_vault/core.py` and service layer

**Changes:**
```python
async def get_document_details(
    self,
    document_id: str | UUID,
    agent_id: str | UUID,
    include_versions: bool = True,
    include_permissions: bool = False,
) -> Dict[str, Any]:
    """
    Get detailed document information.
    
    Args:
        document_id: Document UUID
        agent_id: Agent UUID (requester)
        include_versions: Include version history
        include_permissions: Include permissions (owner only)
    
    Returns:
        Dict with document details
    
    Raises:
        DocumentNotFoundError: If document doesn't exist
        PermissionDeniedError: If agent lacks READ access
        PermissionDeniedError: If include_permissions=True and agent is not owner
    """
    
    # ... existing code ...
    
    if include_permissions:
        # Check if agent is owner (has ADMIN permission)
        agent_perms = await self.get_permissions(
            document_id=document_id,
            agent_id=agent_id
        )
        
        is_owner = any(
            p["permission"] == "ADMIN" 
            for p in agent_perms.get("permissions", [])
        )
        
        if not is_owner:
            raise PermissionDeniedError(
                "Only document owners (ADMIN permission) can view permissions"
            )
        
        # Agent is owner - include all permissions
        all_perms = await self.get_permissions(
            document_id=document_id,
            agent_id=None  # Get all permissions
        )
        details["permissions"] = all_perms["permissions"]
    
    return details
```

#### 4.2: Add Tests
**File**: `tests/test_core_permissions.py`

```python
async def test_get_document_details_permissions_owner_only(vault):
    """Test that only owners can see permissions."""
    # Upload document
    doc = await vault.upload(...)
    
    # Owner can see permissions
    details = await vault.get_document_details(
        document_id=doc.id,
        agent_id=owner_id,
        include_permissions=True
    )
    assert "permissions" in details
    
    # Grant READ to another agent
    await vault.set_permissions(...)
    
    # Non-owner cannot see permissions
    with pytest.raises(PermissionDeniedError, match="Only document owners"):
        await vault.get_document_details(
            document_id=doc.id,
            agent_id=reader_id,
            include_permissions=True
        )
```

---

### Task 5: Remove Unused org_id Parameter ⚡ LOW PRIORITY

**Objective**: Clean up get_permissions() signature.

#### 5.1: Update Method Signature
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def get_permissions(
    self,
    document_id: str | UUID,
    agent_id: Optional[str | UUID] = None,
    org_id: Optional[str | UUID] = None,  # ❌ REMOVE
) -> Dict[str, Any]:
```

**After:**
```python
async def get_permissions(
    self,
    document_id: str | UUID,
    agent_id: Optional[str | UUID] = None,
) -> Dict[str, Any]:
    """
    Get permissions for a document.
    
    Args:
        document_id: Document UUID
        agent_id: Optional agent UUID to filter permissions
    
    Returns:
        Dict with permissions list
    
    Raises:
        DocumentNotFoundError: If document doesn't exist
    """
```

#### 5.2: Update Examples
Remove any usage of `org_id` parameter in examples.

---

### Task 6: Add Type Safety to set_permissions ⚡ MEDIUM PRIORITY

**Objective**: Use Pydantic model instead of dict for permissions.

#### 6.1: Create Permission Model
**File**: `src/doc_vault/database/schemas/permission.py` (NEW or update existing)

```python
from datetime import datetime
from typing import Any, Dict, Optional
from uuid import UUID
from pydantic import BaseModel, Field, validator

class PermissionGrant(BaseModel):
    """
    Permission grant for set_permissions().
    
    Represents a single permission to grant to an agent.
    """
    agent_id: UUID | str = Field(..., description="Agent UUID")
    permission: str = Field(..., description="Permission level")
    expires_at: Optional[datetime] = Field(None, description="Optional expiration")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata")
    
    @validator("permission")
    def validate_permission(cls, v):
        allowed = ["READ", "WRITE", "DELETE", "SHARE", "ADMIN"]
        if v not in allowed:
            raise ValueError(f"Permission must be one of {allowed}")
        return v
    
    @validator("agent_id")
    def validate_agent_id(cls, v):
        if isinstance(v, str):
            try:
                UUID(v)
            except ValueError:
                raise ValueError("agent_id must be a valid UUID string")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "agent_id": "550e8400-e29b-41d4-a716-446655440000",
                "permission": "READ",
                "expires_at": "2026-01-01T00:00:00Z",
                "metadata": {"granted_reason": "project collaboration"}
            }
        }
```

#### 6.2: Update set_permissions()
**File**: `src/doc_vault/core.py`

**Before:**
```python
async def set_permissions(
    self,
    document_id: str | UUID,
    permissions: List[dict],  # ❌
    granted_by: str | UUID,
) -> List[Any]:
```

**After:**
```python
from doc_vault.database.schemas.permission import PermissionGrant

async def set_permissions(
    self,
    document_id: str | UUID,
    permissions: List[PermissionGrant],  # ✅ Typed
    granted_by: str | UUID,
) -> List[DocumentACL]:
    """
    Set permissions for a document in bulk.
    
    Args:
        document_id: Document UUID
        permissions: List of PermissionGrant objects
        granted_by: UUID of agent granting permissions
    
    Returns:
        List[DocumentACL]: Created/updated permission records
    
    Raises:
        ValidationError: If permission data is invalid
        DocumentNotFoundError: If document doesn't exist
        AgentNotFoundError: If granting agent doesn't exist
        PermissionDeniedError: If granting agent lacks ADMIN permission
    
    Example:
        from doc_vault.database.schemas.permission import PermissionGrant
        
        await vault.set_permissions(
            document_id=doc_id,
            permissions=[
                PermissionGrant(
                    agent_id=agent1_id,
                    permission="READ"
                ),
                PermissionGrant(
                    agent_id=agent2_id,
                    permission="WRITE",
                    expires_at=datetime(2026, 1, 1)
                ),
            ],
            granted_by=admin_id
        )
    """
    # Pydantic validation happens automatically
    # Convert PermissionGrant to dict for service layer
    perms_dicts = [p.model_dump() for p in permissions]
    
    return await self._access_service.set_permissions_bulk(
        document_id=document_id,
        permissions=perms_dicts,
        granted_by=granted_by,
    )
```

#### 6.3: Update Examples
**File**: `examples/access_control.py` and others

```python
from doc_vault.database.schemas.permission import PermissionGrant

# Old way (still works for backwards compat)
await vault.set_permissions(
    document_id=doc.id,
    permissions=[{"agent_id": agent_id, "permission": "READ"}],
    granted_by=admin_id
)

# New way (recommended)
await vault.set_permissions(
    document_id=doc.id,
    permissions=[
        PermissionGrant(agent_id=agent_id, permission="READ")
    ],
    granted_by=admin_id
)
```

---

### Task 7: Add Raises to All Docstrings ⚡ LOW PRIORITY

**Objective**: Document all exceptions in method docstrings.

#### 7.1: Create Documentation Template
**File**: `docs/docstring_template.md`

```markdown
# DocVault Docstring Template

All public methods must include:
1. Brief description
2. Args section with types
3. Returns section with type
4. Raises section with all exceptions
5. Example section (for complex methods)

Example:
```python
async def method_name(
    self,
    param1: str,
    param2: Optional[int] = None,
) -> ReturnType:
    """
    Brief one-line description.
    
    Longer description with details about behavior,
    edge cases, and important notes.
    
    Args:
        param1: Description of param1
        param2: Description of param2 (optional)
    
    Returns:
        ReturnType: Description of return value
    
    Raises:
        ValidationError: When param1 is invalid format
        NotFoundError: When resource doesn't exist
        PermissionDeniedError: When user lacks permission
        NetworkError: When external service fails
    
    Example:
        result = await obj.method_name(
            param1="value",
            param2=42
        )
    """
```

#### 7.2: Update All SDK Methods
**File**: `src/doc_vault/core.py`

**Methods to Update:**
- upload()
- download()
- update_metadata()
- delete()
- list_docs()
- search()
- get_permissions()
- set_permissions()
- restore_version()
- register_organization()
- register_agent()
- get_organization()
- get_agent()
- delete_organization()
- remove_agent()
- get_document_details()
- transfer_ownership()

**For Each Method:**
1. Add comprehensive Raises section
2. Document all possible exceptions
3. Include when each exception is raised

---

## Implementation Plan

### Phase 1: Critical Fixes (Week 1)

**Day 1-2: Upload Unification**
- Task 1.1: Update SDK upload() signature ✅
- Task 1.2: Update service layer ✅
- Task 1.3: Remove replace() method ✅
- Task 1.4: Add tests for all input types ✅

**Day 3-4: Method Signature Cleanup**
- Task 2.1: Update register_organization() ✅
- Task 2.2: Update register_agent() ✅
- Task 2.3: Update get_organization() ✅
- Task 2.4: Update get_agent() ✅
- Task 2.5: Update all examples ✅

**Day 5: Hierarchical Listing**
- Task 3.1: Update service layer ✅
- Task 3.2: Verify/update repository layer ✅
- Task 3.3: Add tests ✅

### Phase 2: Security & Polish (Week 2)

**Day 1: Permission Security**
- Task 4.1: Fix get_document_details() ✅
- Task 4.2: Add tests ✅

**Day 2: Type Safety**
- Task 6.1: Create PermissionGrant model ✅
- Task 6.2: Update set_permissions() ✅
- Task 6.3: Update examples ✅

**Day 3: Cleanup**
- Task 5.1: Remove org_id from get_permissions() ✅
- Task 5.2: Update examples ✅

**Day 4-5: Documentation**
- Task 7.1: Create docstring template ✅
- Task 7.2: Update all SDK methods ✅
- Task 1.5: Add examples/upload_types.py ✅

### Phase 3: Testing & Validation (Week 3)

**Day 1-2: Comprehensive Testing**
- Run full test suite
- Add missing tests
- Fix any failures

**Day 3: Example Validation**
- Run all examples
- Fix any issues
- Add README.md updates

**Day 4-5: Documentation Review**
- Update API.md
- Update CHANGELOG.md
- Create v2.1 migration notes

---

## Testing Strategy

### Unit Tests Required
- ✅ Upload with all input types (file path, text, bytes, BinaryIO)
- ✅ Upload with prefix
- ✅ Version creation vs replacement
- ✅ Hierarchical listing (flat, recursive, max_depth)
- ✅ Permission security (owner-only permissions view)
- ✅ Type validation for PermissionGrant
- ✅ Method signature changes (all refactored methods)

### Integration Tests Required
- ✅ End-to-end upload workflow
- ✅ End-to-end versioning workflow
- ✅ Hierarchical document organization
- ✅ Permission management workflow

### Example Validation
- ✅ All examples run without errors
- ✅ Examples demonstrate best practices
- ✅ Examples cover new features

---

## Timeline

### Week 1: Critical Fixes
- **Monday-Tuesday**: Upload unification (Task 1)
- **Wednesday-Thursday**: Method signatures (Task 2)
- **Friday**: Hierarchical listing (Task 3)

### Week 2: Security & Polish
- **Monday**: Permission security (Task 4)
- **Tuesday**: Type safety (Task 6)
- **Wednesday**: Cleanup (Task 5)
- **Thursday-Friday**: Documentation (Task 7, examples)

### Week 3: Testing & Release
- **Monday-Tuesday**: Comprehensive testing
- **Wednesday**: Example validation
- **Thursday**: Documentation review
- **Friday**: Release v2.1.0

**Total Duration**: 3 weeks  
**Release Target**: December 12, 2025

---

## Success Criteria

### Functional
- ✅ Upload works with all input types (str path, str content, bytes, BinaryIO)
- ✅ Prefix parameter actually organizes documents hierarchically
- ✅ Version control works (create_version parameter)
- ✅ Hierarchical listing works (prefix, recursive, max_depth)
- ✅ Permission security enforced (owner-only permissions view)
- ✅ Type safety for permissions (PermissionGrant model)
- ✅ No unused parameters
- ✅ Consistent method signatures

### Testing
- ✅ 100% of new functionality has unit tests
- ✅ All integration tests pass
- ✅ All examples run successfully
- ✅ Code coverage >80%

### Documentation
- ✅ All methods have complete docstrings
- ✅ All exceptions documented in Raises section
- ✅ Examples demonstrate new features
- ✅ Migration guide from v2.0 to v2.1

### Quality
- ✅ No breaking changes to existing v2.0 code (except deprecated parameters)
- ✅ Performance unchanged or improved
- ✅ All mypy type checks pass
- ✅ All ruff linting passes

---

## Breaking Changes from v2.0 to v2.1

### Method Signature Changes (Breaking)

| Method | v2.0 | v2.1 | Migration |
|--------|------|------|-----------|
| `register_organization()` | `external_id: str, name: str` | `org_id: UUID\|str` | Remove `name`, rename `external_id` |
| `register_agent()` | `external_id: str, ..., name, email, agent_type` | `agent_id: UUID\|str, ...` | Remove `name/email/agent_type`, rename `external_id` |
| `get_organization()` | `external_id: str` | `org_id: UUID\|str` | Rename parameter |
| `get_agent()` | `external_id: str` | `agent_id: UUID\|str` | Rename parameter |
| `get_permissions()` | `..., org_id: Optional[UUID]` | `...,` (removed) | Remove `org_id` parameter |
| `set_permissions()` | `permissions: List[dict]` | `permissions: List[PermissionGrant]` | Use model class |

### Removed Methods
- `replace()` - merged into `upload()` with `create_version` parameter

### New Parameters
- `upload()`: Added `prefix`, `create_version`, `change_description`
- `list_docs()`: Parameters now actually implemented (prefix, recursive, max_depth)

### Security Changes
- `get_document_details(include_permissions=True)` now requires ADMIN permission

---

## Migration Guide: v2.0 → v2.1

### 1. Update Organization/Agent Registration

**Before (v2.0):**
```python
org = await vault.register_organization(
    external_id="org-123",
    name="My Org"  # Deprecated
)

agent = await vault.register_agent(
    external_id="agent-456",
    organization_id="org-123",
    name="John Doe",      # Deprecated
    email="john@example.com",  # Deprecated
    agent_type="human"    # Deprecated
)
```

**After (v2.1):**
```python
org = await vault.register_organization(
    org_id="org-123"
)

agent = await vault.register_agent(
    agent_id="agent-456",
    organization_id="org-123",
    metadata={
        "name": "John Doe",
        "email": "john@example.com",
        "type": "human"
    }
)
```

### 2. Replace replace() with upload()

**Before (v2.0):**
```python
await vault.replace(
    document_id=doc_id,
    file_input=new_content,
    agent_id=agent_id,
    change_description="Updated"
)
```

**After (v2.1):**
```python
await vault.upload(
    file_input=new_content,
    name=doc_name,
    organization_id=org_id,
    agent_id=agent_id,
    create_version=True,  # Or False to replace
    change_description="Updated"
)
```

### 3. Use PermissionGrant Model

**Before (v2.0):**
```python
await vault.set_permissions(
    document_id=doc_id,
    permissions=[
        {"agent_id": agent_id, "permission": "READ"}
    ],
    granted_by=admin_id
)
```

**After (v2.1):**
```python
from doc_vault.database.schemas.permission import PermissionGrant

await vault.set_permissions(
    document_id=doc_id,
    permissions=[
        PermissionGrant(agent_id=agent_id, permission="READ")
    ],
    granted_by=admin_id
)
```

### 4. Hierarchical Document Organization

**New in v2.1:**
```python
# Upload with prefix
doc = await vault.upload(
    file_input=content,
    name="Report",
    organization_id=org_id,
    agent_id=agent_id,
    prefix="/reports/2025/q4/"
)

# List hierarchically
results = await vault.list_docs(
    organization_id=org_id,
    agent_id=agent_id,
    prefix="/reports/",
    recursive=True,
    max_depth=2
)
```

---

## Notes

### Design Decisions

1. **Upload Unification**: Merging `replace()` into `upload()` simplifies the API. Users no longer need to remember two methods.

2. **Parameter Naming**: Standardizing on `org_id` and `agent_id` makes the API more intuitive and consistent.

3. **Type Safety**: Using Pydantic models for `set_permissions()` catches errors at validation time instead of runtime.

4. **Security**: Restricting permissions view to owners prevents information leakage about document access.

5. **Hierarchical Listing**: Implementing prefix-based organization enables S3-like document structure for better organization.

### Backward Compatibility

Most changes are **breaking** but justifiable:
- Deprecated parameters should be removed, not kept forever
- Consistent API is more valuable than backward compatibility
- v2.1 is still part of v2.x, major version already indicates breaking changes

### Future Enhancements (v2.2+)

- Bulk upload operation
- Batch permission updates
- Advanced search with prefix filtering
- Document move/copy between prefixes
- Prefix-based quotas and limits

---

**End of v2.1 Refinement Plan**
